package com.magic.lineone.db;

import java.beans.PropertyVetoException;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.apache.log4j.Logger;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import com.mchange.v2.c3p0.DataSources;

/**
 * A dispatcher that allows the caller to query on one database without knowing
 * the partition strategy itself. A PartitionStrategy should be registered to
 * the dispatcher before use.
 * 
 * @author magiccash
 * 
 */
public class DatabaseAdapter {

    public static final int             DEFAULT_MIN_POOL_SIZE             = 10;
    public static final int             DEFAULT_MAX_POOL_SIZE             = 800;
    public static final int             DEFAULT_MAX_IDLE_TIME             = 0;
    public static final int             DEFAULT_MAX_STATEMENT_PER_CONNECT = 20;
    public static final int             DEFAULT_RETRY_ATTEMPTS            = 60;
    public static final int             DEFAULT_RETRY_DELAY               = 3;
    public static final int             DEFAULT_IDLE_TEST_PERIOD          = 30;

    private int                         minPoolSize                       = DEFAULT_MIN_POOL_SIZE;
    private int                         maxPoolSize                       = DEFAULT_MAX_POOL_SIZE;
    private int                         maxIdleTime                       = DEFAULT_MAX_IDLE_TIME;
    private int                         maxStatementCacheSize             = maxPoolSize
                                                                                  * DEFAULT_MAX_STATEMENT_PER_CONNECT;
    private int                         maxStatementsPerConnection        = DEFAULT_MAX_STATEMENT_PER_CONNECT;
    private int                         retryAttempts                     = DEFAULT_RETRY_ATTEMPTS;
    private int                         retryDelay                        = DEFAULT_RETRY_DELAY;
    private int                         idleTestPeriod                    = DEFAULT_IDLE_TEST_PERIOD;
    private boolean                     testConnectionOnCheckout          = false;

    private final ComboPooledDataSource source                            = new ComboPooledDataSource ();

    public DatabaseAdapter (String jdbcurl) {

        try {
            source.setDriverClass ("com.mysql.jdbc.Driver");
        }
        catch (PropertyVetoException e) {
            Logger.getLogger (this.getClass ()).error ("failed to load MySQL JDBC driver", e);

            throw new UnsupportedOperationException ("Cannot load MySQL JDBC driver");
        }
        source.setJdbcUrl (jdbcurl);

        source.setInitialPoolSize (minPoolSize);
        source.setMinPoolSize (minPoolSize);
        source.setMaxPoolSize (maxPoolSize);
        source.setMaxStatements (maxStatementCacheSize);
        source.setMaxStatementsPerConnection (maxStatementsPerConnection);
        source.setMaxIdleTime (maxIdleTime);

        source.setBreakAfterAcquireFailure (false);
        source.setAcquireRetryAttempts (this.retryAttempts);
        source.setAcquireRetryDelay (retryDelay);

        source.setIdleConnectionTestPeriod (idleTestPeriod);
        source.setPreferredTestQuery ("SELECT 1");
        source.setTestConnectionOnCheckout (this.testConnectionOnCheckout);
    }

    /**
     * Get the proper db connection string by the key, and return the
     * corresponding provider. Initilize the connection to the connection string
     * if not yet.
     * 
     * @param key
     * @return
     */
    private DataSource getDataSource () {

        return source;
    }

    public synchronized Connection getConnection () throws SQLException {

        return this.getDataSource ().getConnection ();
    }

    public boolean executeQuery (String key, String query) throws SQLException {

        return executeQuery (key, query, false);
    }

    public boolean executeQuery (String key, String query, boolean ignoreExceptions) throws SQLException {

        Connection connection = null;
        Statement statement = null;

        try {
            connection = this.getConnection ();

            int autoGeneratedKey = Statement.NO_GENERATED_KEYS;
            if (query.trim ().toUpperCase ().startsWith ("INSERT")) {
                autoGeneratedKey = Statement.RETURN_GENERATED_KEYS;
            }

            statement = connection.createStatement ();
            statement.execute (query, autoGeneratedKey);
        }
        catch (SQLException e) {
            Logger.getLogger (this.getClass ()).error ("Error while executing SQL query " + query, e);

            if (ignoreExceptions) {
                return false;
            }
            else {
                throw e;
            }
        }
        finally {
            if (statement != null) {
                statement.close ();
            }
            if (connection != null) {
                connection.close ();
            }
        }

        return true;
    }

    public int getMinPoolSize () {

        return minPoolSize;
    }

    public void setMinPoolSize (int minPoolSize) {

        this.minPoolSize = minPoolSize;
    }

    public int getMaxPoolSize () {

        return maxPoolSize;
    }

    public void setMaxPoolSize (int maxPoolSize) {

        this.maxPoolSize = maxPoolSize;
        source.setMaxPoolSize (maxPoolSize);
        this.maxStatementCacheSize = this.maxPoolSize * this.maxStatementsPerConnection;
        source.setMaxStatements (maxStatementCacheSize);
    }

    public int getMaxStatementCacheSize () {

        return maxStatementCacheSize;
    }

    public void setMaxStatementCacheSize (int maxStatementCacheSize) {

        this.maxStatementCacheSize = maxStatementCacheSize;
    }

    public void close () {

        try {
            DataSources.destroy (source);
        }
        catch (SQLException e) {
            Logger.getLogger (this.getClass ()).error ("Error when destorying connection " + source, e);
        }

    }

    public int getRetryAttempts () {

        return retryAttempts;
    }

    public void setRetryAttempts (int retryAttempts) {

        this.retryAttempts = retryAttempts;
    }

    public int getRetryDelay () {

        return retryDelay;
    }

    public void setRetryDelay (int retryDelay) {

        this.retryDelay = retryDelay;
    }

    public int getIdleTestPeriod () {

        return idleTestPeriod;
    }

    /**
     * Set the period betweed each idle connection test. set to zero to disable
     * auto idle connection test.
     * 
     * @param idleTestPeriod
     */
    public void setIdleTestPeriod (int idleTestPeriod) {

        this.idleTestPeriod = idleTestPeriod;
    }

    public boolean getTestConnectionOnCheckout () {

        return testConnectionOnCheckout;
    }

    public void setTestConnectionOnCheckout (boolean testConnectionOnCheckout) {

        this.testConnectionOnCheckout = testConnectionOnCheckout;
    }

    public int getMaxIdleTime () {

        return maxIdleTime;
    }

    public void setMaxIdleTime (int maxIdleTime) {

        this.maxIdleTime = maxIdleTime;
    }

    public int getMaxStatementsPerConnection () {

        return maxStatementsPerConnection;
    }

    public void setMaxStatementsPerConnection (int maxStatementsPerConnection) {

        this.maxStatementsPerConnection = maxStatementsPerConnection;
        this.maxStatementCacheSize = this.maxPoolSize * this.maxStatementsPerConnection;
    }
}
