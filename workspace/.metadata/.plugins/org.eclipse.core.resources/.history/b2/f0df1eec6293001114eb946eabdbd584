package com.magic.lineone.kt;

import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;

import org.apache.commons.codec.binary.Base64;
import org.apache.log4j.Logger;

import com.magic.lineone.util.ByteUtil;

public class Base64KyotoTycoonClient implements IKyotoTycoonClient {

    private final String baseUrl;

    private final String host;

    private Base64KyotoTycoonClient (String baseUrl) {

        this.baseUrl = baseUrl;
        host = baseUrl.replace ("http://", "");
    }

    private static final HashMap <String, Base64KyotoTycoonClient> instanceMap   = new HashMap <String, Base64KyotoTycoonClient> ();

    private static final Object                                    singletonLock = new Object ();

    private static final String                                    KEY           = "key";

    private static final String                                    VALUE         = "value";

    private static final Base64                                    base64        = new Base64 ();

    public static Base64KyotoTycoonClient getInstance (String baseUrl) {

        if (!instanceMap.containsKey (baseUrl)) {
            synchronized (singletonLock) {
                if (!instanceMap.containsKey (baseUrl)) {
                    Base64KyotoTycoonClient client = new Base64KyotoTycoonClient (baseUrl);
                    instanceMap.put (baseUrl, client);
                }
            }
        }
        return instanceMap.get (baseUrl);
    }

    @Override
    public byte [] getValue (byte [] key) {

        try {
            String outputStr;
            outputStr = new String (base64.encode (KEY.getBytes ())) + "\t" + new String (base64.encode (key));
            URL url = new URL (baseUrl + "/rpc/get");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection ();
            conn.setRequestMethod ("POST");
            conn.setRequestProperty ("Content-Type", "text/tab-separated-values; colenc=B");
            conn.setRequestProperty ("Content-Length", "" + outputStr.length ());
            conn.setDoOutput (true);
            OutputStream os = conn.getOutputStream ();
            os.write (outputStr.getBytes ());
            os.flush ();
            os.close ();
            conn.connect ();
            if (conn.getResponseCode () == 200) {
                String type = conn.getHeaderField ("Content-Type");
                String t = null;
                if (type != null && type.contains ("colenc=")) {
                    t = type.substring (type.indexOf ("colenc=") + "colenc=".length ());
                }
                String len = conn.getHeaderField ("Content-Length");
                int size = 0;
                if (len != null)
                    size = Integer.parseInt (len);
                byte [] b = new byte [size];
                byte [] buffer = new byte [4096];
                int point = 0;
                do {
                    int x = conn.getInputStream ().read (buffer);
                    if (x == -1)
                        break;
                    for (int i = 0; i < x; i++, point++) {
                        b [point] = buffer [i];
                    }
                } while (true);
                if (t == null) {
                    return ByteUtil.subbytes (b, 6, b.length - 1);
                }
                else if (t.equalsIgnoreCase ("u")) {
                    StringBuffer sb = new StringBuffer ();
                    for (byte by : b) {
                        sb.append ((char) by);
                    }
                    byte [] tempbyte = getUTF8Bytes (sb.toString ());
                    return ByteUtil.subbytes (tempbyte, 6, tempbyte.length - 1);
                }
                else if (t.equalsIgnoreCase ("b")) {
                    return base64.decode (ByteUtil.subbytes (b, 9, b.length - 1));
                }
            }
        }
        catch (Exception e) {
            e.printStackTrace ();
            Logger.getLogger (this.getClass ()).error ("Error when get the value.", e);
        }
        return null;
    }

    @Override
    public boolean setValue (byte [] key, byte [] value) {

        try {
            String outputStr;
            outputStr = new String (base64.encode (KEY.getBytes ())) + "\t" + new String (base64.encode (key)) + "\r\n"
                    + new String (base64.encode (VALUE.getBytes ())) + "\t" + new String (base64.encode (value));
            URL url = new URL (baseUrl + "/rpc/set");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection ();
            conn.setRequestMethod ("POST");
            conn.setRequestProperty ("HOST", host);
            conn.setRequestProperty ("Content-Type", "text/tab-separated-values; colenc=B");
            conn.setRequestProperty ("Content-Length", "" + outputStr.length ());
            conn.setDoOutput (true);
            OutputStream os = conn.getOutputStream ();

            os.write (outputStr.getBytes ());
            os.flush ();
            os.close ();
            conn.connect ();
            if (conn.getResponseCode () == 200) {
                return true;
            }
        }
        catch (Exception e) {
            e.printStackTrace ();
            Logger.getLogger (this.getClass ()).error ("Error when get the value.", e);
        }
        return false;
    }

    @Override
    public boolean removeKey (byte [] key) {

        // TODO Auto-generated method stub
        return false;
    }

    private byte [] getUTF8Bytes (String str) {

        byte [] result = new byte [str.length ()];
        int point = 0;
        for (int i = 0; i < str.length (); i++) {
            char c = str.charAt (i);
            if (c == '%') {
                result [point] = getUTFByte (str.charAt (i + 1), str.charAt (i + 2));
                i += 2;
                point++;
            }
            else {
                result [point] = (byte) c;
                point++;
            }
        }
        return ByteUtil.subbytes (result, 0, point);
    }

    private byte getUTFByte (char c1, char c2) {

        int i1 = getHex (c1);
        int i2 = getHex (c2);
        if (i1 >= 0 && i2 >= 0)
            return (byte) (i1 * 16 + i2);
        return -1;
    }

    private byte getHex (char c1) {

        int i1;
        if (c1 >= '0' && c1 <= '9')
            i1 = c1 - 48;
        else if (c1 >= 'a' && c1 <= 'f')
            i1 = c1 - 87;
        else
            return -1;
        return (byte) i1;
    }

    public static void main (String [] args) {

        Base64KyotoTycoonClient client = Base64KyotoTycoonClient.getInstance ("http://192.168.36.162:9000");
        byte [] key = new byte [] {
                1, 2, 3, 4, 5
        };
        byte [] value = new byte [] {
                6, 7, 8, 9, 127
        };
        long t1 = System.currentTimeMillis ();
        client.setValue (key, value);
        long t2 = System.currentTimeMillis ();
        byte [] ret = client.getValue (key);
        long t3 = System.currentTimeMillis ();
        System.out.println ((t2 - t1) + "ms");
        System.out.println ((t3 - t2) + "ms");
        if (ret != null) {
            for (byte b : ret)
                System.out.print (b + " ");
        }
    }

    @Override
    public boolean removeValue (byte [] key) {

        // TODO Auto-generated method stub
        return false;
    }
}
